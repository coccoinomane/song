/**
 * Translation to C of the DRC3JM, DRC3JJ, DRC6J functions to compute 3j and 6j symbols
 * (which are closely related to the Clebsch-Gordan coefficients) from the SLATEC
 * Fortran library. No automatic tools like f2c and fable were used in the process:
 * it was all painstakingly done by hand.
 *
 * The original SLATEC (Sandia, Los Alamos, Air Force Weapons Laboratory) library was
 * written in F77 by the US military in the 70's, and can be found on
 * http://www.netlib.org/slatec. A F90 version can be found on John Burkardt's homepage
 * (http://people.sc.fsu.edu/~jburkardt/f_src/slatec/slatec.html).
 *
 * Guido Walter Pettinari (coccoinomane@gmail.com) on 14.02.2014.
 */

#include "slatec_3j_C.h"

/*
!! DRC3JM evaluates the 3j symbol g(M2) for all allowed values of M2.
!
!***PURPOSE  Evaluate the 3j symbol g(M2) = (L1 L2   L3  )
!                                           (M1 M2 -M1-M2)
!            for all allowed values of M2, the other parameters
!            being held fixed.
!
!***LIBRARY   SLATEC
!***CATEGORY  C19
!***TYPE      DOUBLE PRECISION (RC3JM-S, DRC3JM-D)
!***KEYWORDS  3J COEFFICIENTS, 3J SYMBOLS, CLEBSCH-GORDAN COEFFICIENTS,
!             RACAH COEFFICIENTS, VECTOR ADDITION COEFFICIENTS,
!             WIGNER COEFFICIENTS
!***AUTHOR  Gordon, R. G., Harvard University
!           Schulten, K., Max Planck Institute
!***DESCRIPTION
!
! *Usage:
!
!        DOUBLE PRECISION L1, L2, L3, M1, M2MIN, M2MAX, THRCOF(NDIM)
!        INTEGER NDIM, IER
!
!        call DRC3JM (L1, L2, L3, M1, M2MIN, M2MAX, THRCOF, NDIM, IER)
!
! *Arguments:
!
!     L1 :IN      Parameter in 3j symbol.
!
!     L2 :IN      Parameter in 3j symbol.
!
!     L3 :IN      Parameter in 3j symbol.
!
!     M1 :IN      Parameter in 3j symbol.
!
!     M2MIN :OUT  Smallest allowable M2 in 3j symbol.
!
!     M2MAX :OUT  Largest allowable M2 in 3j symbol.
!
!     THRCOF :OUT Set of 3j coefficients generated by evaluating the
!                 3j symbol for all allowed values of M2.  THRCOF(I)
!                 will contain g(M2MIN+I-1), I=1,2,...,M2MAX-M2MIN+1.
!
!     NDIM :IN    Declared length of THRCOF in calling program.
!
!     IER :OUT    Error flag.
!                 IER=0 No errors.
!                 IER=1 Either L1 < ABS(M1) or L1+ABS(M1) non-integer.
!                 IER=2 ABS(L1-L2) <= L3 <= L1+L2 not satisfied.
!                 IER=3 L1+L2+L3 not an integer.
!                 IER=4 M2MAX-M2MIN not an integer.
!                 IER=5 M2MAX less than M2MIN.
!                 IER=6 NDIM less than M2MAX-M2MIN+1.
!
! *Description:
!
!     Although conventionally the parameters of the vector addition
!  coefficients satisfy certain restrictions, such as being integers
!  or integers plus 1/2, the restrictions imposed on input to this
!  subroutine are somewhat weaker. See, for example, Section 27.9 of
!  Abramowitz and Stegun or Appendix C of Volume II of A. Messiah.
!  The restrictions imposed by this subroutine are
!       1. L1 >= ABS(M1) and L1+ABS(M1) must be an integer;
!       2. ABS(L1-L2) <= L3 <= L1+L2;
!       3. L1+L2+L3 must be an integer;
!       4. M2MAX-M2MIN must be an integer, where
!          M2MAX=MIN(L2,L3-M1) and M2MIN=MAX(-L2,-L3-M1).
!  If the conventional restrictions are satisfied, then these
!  restrictions are met.
!
!     The user should be cautious in using input parameters that do
!  not satisfy the conventional restrictions. For example, the
!  the subroutine produces values of
!       g(M2) = (0.751.50   1.75  )
!               (0.25  M2  -0.25-M2)
!  for M2=-1.5,-0.5,0.5,1.5 but none of the symmetry properties of the
!  3j symbol, set forth on page 1056 of Messiah, is satisfied.
!
!     The subroutine generates g(M2MIN), g(M2MIN+1), ..., g(M2MAX)
!  where M2MIN and M2MAX are defined above. The sequence g(M2) is
!  generated by a three-term recurrence algorithm with scaling to
!  control overflow. Both backward and forward recurrence are used to
!  maintain numerical stability. The two recurrence sequences are
!  matched at an interior point and are normalized from the unitary
!  property of 3j coefficients and Wigner's phase convention.
!
!    The algorithm is suited to applications in which large quantum
!  numbers arise, such as in molecular dynamics.
!
!***REFERENCES  1. Abramowitz, M., and Stegun, I. A., Eds., Handbook
!                  of Mathematical Functions with Formulas, Graphs
!                  and Mathematical Tables, NBS Applied Mathematics
!                  Series 55, June 1964 and subsequent printings.
!               2. Messiah, Albert., Quantum Mechanics, Volume II,
!                  North-Holland Publishing Company, 1963.
!               3. Schulten, Klaus and Gordon, Roy G., Exact recursive
!                  evaluation of 3j and 6j coefficients for quantum-
!                  mechanical coupling of angular momenta, J Math
!                  Phys, v 16, no. 10, October 1975, pp. 1961-1970.
!               4. Schulten, Klaus and Gordon, Roy G., Semiclassical
!                  approximations to 3j and 6j coefficients for
!                  quantum-mechanical coupling of angular momenta,
!                  J Math Phys, v 16, no. 10, October 1975,
!                  pp. 1971-1988.
!               5. Schulten, Klaus and Gordon, Roy G., Recursive
!                  evaluation of 3j and 6j coefficients, Computer
!                  Phys Comm, v 11, 1976, pp. 269-278.
!***ROUTINES CALLED  D1MACH, XERMSG
!***REVISION HISTORY  (YYMMDD)
!   750101  DATE WRITTEN
!   880515  SLATEC prologue added by G. C. Nielson, NBS; parameters
!           HUGE and TINY revised to depend on D1MACH.
!   891229  Prologue description rewritten; other prologue sections
!           revised; MMATCH (location of match point for recurrences)
!           removed from argument list; argument IER changed to serve
!           only as an error flag (previously, in cases without error,
!           it returned the number of scalings); number of error codes
!           increased to provide more precise error information;
!           program comments revised; SLATEC error handler calls
!           introduced to enable printing of error messages to meet
!           SLATEC standards. These changes were done by D. W. Lozier,
!           M. A. McClain and J. M. Smith of the National Institute
!           of Standards and Technology, formerly NBS.
!   910415  Mixed type expressions eliminated; variable C1 initialized;
!           description of THRCOF expanded. These changes were done by
!           D. W. Lozier.
!***END PROLOGUE  DRC3JM
*/

int drc3jm (double L1, double L2, double L3, double M1, /* IN, parameters */
            double *M2MIN, double *M2MAX,               /* OUT, limits of m2 */
            double * THRCOF,                            /* OUT, result */
            int NDIM,                                   /* IN, length of result */
            // int * IER,                                  /* OUT, error code, 0 ok */
            ErrorMsg errmsg)
{
  
  int I, INDEX, LSTEP, N, NFIN, NFINP1, NFINP2, NFINP3, NLIM, NSTEP2;
  double A1, A1S, C1, C1OLD, C2, CNORM, D1MACH, DV, EPS,
         HUGE_, M2, M3, NEWFAC, OLDFAC, ONE, RATIO, SIGN1,
         SIGN2, SRHUGE, SRTINY, SUM1, SUM2, SUMBAC,
         SUMFOR, SUMUNI, THRESH, TINY, TWO, X, X1, X2, X3,
         Y, Y1, Y2, Y3, ZERO;

  // *IER = 0;
  ZERO = 0.0;
  EPS = 0.01;
  ONE = 1.0;
  TWO = 2.0;
  
  /* HUGE is the square root of one twentieth of the largest floating point number,
  approximately. DBL_MAX is defined in float.h. */
  HUGE_ = sqrt(DBL_MAX/20.0);
  SRHUGE = sqrt(HUGE_);
  TINY = 1.0/HUGE_;
  SRTINY = 1.0/SRHUGE;

  /* Limits for M2 */
  *M2MIN = MAX(-L2,-L3-M1);
  *M2MAX = MIN(L2,L3-M1);

  /* Check error conditions 1, 2, and 3. */
  if (L1-fabs(M1)+EPS < ZERO) {
    // *IER=1;
    class_stop (
      errmsg,
      "L1-ABS(M1) less than zero or L1+fabs(M1) not integer.");
  }
  else if ((L1+L2-L3 < -EPS) || (L1-L2+L3 < -EPS) || (-L1+L2+L3 < -EPS)) {
    // *IER=2;
    class_stop (
      errmsg,
      "L1, L2, L3 do not satisfy triangular condition");
  }


  if (*M2MIN < *M2MAX-EPS)   goto _20_;
  if (*M2MIN < *M2MAX+EPS)   goto _10_;

  /* Check error condition 5 */
  // *IER=5;
  class_stop (
    errmsg,
    "M2MIN greater than M2MAX");

  /* This is reached in case that M2 and M3 can take only one value */
  _10_:
    THRCOF[1-1] = ALTERNATING_SIGN((int)(fabs(L2-L3-M1)+EPS))/sqrt(L1+L2+L3+ONE);
    return _SUCCESS_;

  /* This is reached in case that M1 and M2 take more than one value */
  _20_:
    NFIN = (int)(*M2MAX-*M2MIN+ONE+EPS);
    if (NDIM<NFIN) goto _21_;
    else goto _23_;

  /* Check error condition 6 */
  _21_:
    // *IER=6;
    class_stop (
      errmsg,
      "Dimension of result array for 3j coefficients too small");


  /* Start of forward recursion from M2 = M2MIN (GO TO 23 in Fortran code) */
  _23_:
  M2 = *M2MIN;
  THRCOF[0] = SRTINY;
  NEWFAC = 0.0;
  C1 = 0.0;
  SUM1 = TINY;

  LSTEP = 1;
  _30_:
  LSTEP = LSTEP + 1;
  M2 = M2 + ONE;
  M3 = - M1 - M2;

  OLDFAC = NEWFAC;
  A1 = (L2-M2+ONE) * (L2+M2) * (L3+M3+ONE) * (L3-M3);
  NEWFAC = sqrt(A1);

  DV = (L1+L2+L3+ONE)*(L2+L3-L1) - (L2-M2+ONE)*(L3+M3+ONE) - (L2+M2-ONE)*(L3-M3-ONE);

  if (LSTEP<=2)  goto _32_;
  else goto _31_;
    
  _31_:
    C1OLD = fabs(C1);
  _32_:
    C1 = - DV / NEWFAC;

  if (LSTEP > 2)   goto _60_;

  /* If M2 = M2MIN + 1, the third term in the recursion equation vanishes, hence */

  X = SRTINY * C1;
  THRCOF[1] = X;
  SUM1 = SUM1 + TINY * C1*C1;
  if (LSTEP == NFIN) goto _220_;
  goto _30_;

  _60_:
    C2 = - OLDFAC / NEWFAC;

  /* Recursion to the next 3j coefficient */
  X = C1 * THRCOF[LSTEP-1-1] + C2 * THRCOF[LSTEP-2-1];
  THRCOF[LSTEP-1] = X;
  SUMFOR = SUM1;
  SUM1 = SUM1 + X*X;
  if (LSTEP == NFIN)   goto _100_;

  /* See if last unnormalized 3j coefficient exceeds SRHUGE */
  if (fabs(X) < SRHUGE)   goto _80_;

  /* This is reached if last 3j coefficient larger than SRHUGE,
  so that the recursion series THRCOF(1), ... , THRCOF(LSTEP)
  has to be rescaled to prevent overflow */
  for (I=1; I <= LSTEP; ++I) {
    if ( fabs(THRCOF[I-1]) < SRTINY)
      THRCOF[I-1] = ZERO;
    THRCOF[I-1] = THRCOF[I-1] / SRHUGE;
  } 
  SUM1 = SUM1 / HUGE_;
  SUMFOR = SUMFOR / HUGE_;
  X = X / SRHUGE;

  /* As long as fabs(C1) is decreasing, the recursion proceeds towards
  increasing 3j values and, hence, is numerically stable.  Once
  an increase of fabs(C1) is detected, the recursion direction is
  reversed. */
  _80_:
    if (C1OLD<=fabs(C1))
      goto _100_;
    else
      goto _30_;

  /* Keep three 3j coefficients around MMATCH for comparison later
  with backward recursion values */

  _100_:
    NSTEP2 = NFIN - LSTEP + 3;
    X1 = X;
    X2 = THRCOF[LSTEP-1-1];
    X3 = THRCOF[LSTEP-2-1];
  //   100 CONTINUE
  // !     MMATCH = M2 - 1
  //   NSTEP2 = NFIN - LSTEP + 3
  //   X1 = X
  //   X2 = THRCOF(LSTEP-1)
  //   X3 = THRCOF(LSTEP-2)

  /* Starting backward recursion from M2MAX taking NSTEP2 steps, so
  that forwards and backwards recursion overlap at the three points
  M2 = MMATCH+1, MMATCH, MMATCH-1. */

  NFINP1 = NFIN + 1;
  NFINP2 = NFIN + 2;
  NFINP3 = NFIN + 3;
  THRCOF[NFIN-1] = SRTINY;
  SUM2 = TINY;

  M2 = *M2MAX + TWO;
  LSTEP = 1;
  _110_: LSTEP = LSTEP + 1;
  M2 = M2 - ONE;
  M3 = - M1 - M2;
  OLDFAC = NEWFAC;
  A1S = (L2-M2+TWO) * (L2+M2-ONE) * (L3+M3+TWO) * (L3-M3-ONE);
  NEWFAC = sqrt(A1S);
  DV = (L1+L2+L3+ONE)*(L2+L3-L1) - (L2-M2+ONE)*(L3+M3+ONE) - (L2+M2-ONE)*(L3-M3-ONE);
  C1 = - DV / NEWFAC;
  if ( LSTEP > 2)   goto _120_;
  
  /* If M2 = M2MAX + 1 the third term in the recursion equation vanishes */
  Y = SRTINY * C1;
  THRCOF[NFIN-1-1] = Y;
  if (LSTEP == NSTEP2)   goto _200_;
  SUMBAC = SUM2;
  SUM2 = SUM2 + Y*Y;
  goto _110_;

  _120_: C2 = - OLDFAC / NEWFAC;

  /* Recursion to the next 3j coefficient */
  Y = C1 * THRCOF[NFINP2-LSTEP-1] + C2 * THRCOF[NFINP3-LSTEP-1];

  if (LSTEP == NSTEP2)   goto _200_;

  THRCOF[NFINP1-LSTEP-1] = Y;
  SUMBAC = SUM2;
  SUM2 = SUM2 + Y*Y;

  /* See if last 3j coefficient exceeds SRHUGE */

  if (fabs(Y) < SRHUGE)   goto _110_;

  /* This is reached if last 3j coefficient larger than SRHUGE,
  so that the recursion series THRCOF(NFIN), ... , THRCOF(NFIN-LSTEP+1)
  has to be rescaled to prevent overflow. */

  for (I=1; I <= LSTEP; ++I) {
    INDEX = NFIN - I + 1;
    if (fabs(THRCOF[INDEX-1]) < SRTINY)
      THRCOF[INDEX-1] = ZERO;
    THRCOF[INDEX-1] = THRCOF[INDEX-1] / SRHUGE;
  }

  SUM2 = SUM2 / HUGE_;
  SUMBAC = SUMBAC / HUGE_;
  
  goto _110_;


  /* The forward recursion 3j coefficients X1, X2, X3 are to be matched
  with the corresponding backward recursion values Y1, Y2, Y3. */
  
  _200_: Y3 = Y;
  Y2 = THRCOF[NFINP2-LSTEP-1];
  Y1 = THRCOF[NFINP3-LSTEP-1];

  /* Determine now RATIO such that YI = RATIO * XI  (I=1,2,3) holds
  with minimal error. */
  RATIO = ( X1*Y1 + X2*Y2 + X3*Y3 ) / ( X1*X1 + X2*X2 + X3*X3 );
  NLIM = NFIN - NSTEP2 + 1;
  
  if ( fabs(RATIO) < ONE)   goto _211_;
  
  for (N=1; N <= NLIM; ++N) {
    THRCOF[N-1] = RATIO * THRCOF[N-1];
  }
  
  SUMUNI = RATIO * RATIO * SUMFOR + SUMBAC;
  goto _230_;
  
  _211_: NLIM = NLIM + 1;
  RATIO = ONE / RATIO;
  for (N=NLIM; N <= NFIN; ++N) {
    THRCOF[N-1] = RATIO * THRCOF[N-1];
  }
  SUMUNI = SUMFOR + RATIO*RATIO*SUMBAC;
  goto _230_;
  
  _220_: SUMUNI = SUM1;
  
  
  /* Normalize 3j coefficients */
  _230_: CNORM = ONE / sqrt((L1+L1+ONE) * SUMUNI);

  /* Sign convention for last 3j coefficient determines overall phase */
  SIGN1 = copysign(ONE,THRCOF[NFIN-1]);
  SIGN2 = ALTERNATING_SIGN((int)(fabs(L2-L3-M1)+EPS));
  if ((SIGN1*SIGN2)<=0) goto _235_;
  else goto _236_;
  _235_: CNORM = - CNORM;
  _236_: if (fabs(CNORM) < ONE)   goto _250_;
  
  for (N=1; N <= NFIN; ++N) {
    THRCOF[N-1] = CNORM * THRCOF[N-1];
  }

  return _SUCCESS_;
  
  _250_: THRESH = TINY / fabs(CNORM);
  for (N=1; N <= NFIN; ++N) {
    if (fabs(THRCOF[N-1]) < THRESH)   THRCOF[N-1] = ZERO;
    THRCOF[N-1] = CNORM * THRCOF[N-1];
  }
  
  return _SUCCESS_;
  
}





/*
!! DRC3JJ evaluates the 3J symbol f(L1) for all allowed values of L1.
!
!***PURPOSE  Evaluate the 3j symbol f(L1) = (  L1   L2 L3)
!                                           (-M2-M3 M2 M3)
!            for all allowed values of L1, the other parameters
!            being held fixed.
!
!***LIBRARY   SLATEC
!***CATEGORY  C19
!***TYPE      DOUBLE PRECISION (RC3JJ-S, DRC3JJ-D)
!***KEYWORDS  3J COEFFICIENTS, 3J SYMBOLS, CLEBSCH-GORDAN COEFFICIENTS,
!             RACAH COEFFICIENTS, VECTOR ADDITION COEFFICIENTS,
!             WIGNER COEFFICIENTS
!***AUTHOR  Gordon, R. G., Harvard University
!           Schulten, K., Max Planck Institute
!***DESCRIPTION
!
! *Usage:
!
!        DOUBLE PRECISION L2, L3, M2, M3, L1MIN, L1MAX, THRCOF(NDIM)
!        INTEGER NDIM, IER
!
!        call DRC3JJ (L2, L3, M2, M3, L1MIN, L1MAX, THRCOF, NDIM, IER)
!
! *Arguments:
!
!     L2 :IN      Parameter in 3j symbol.
!
!     L3 :IN      Parameter in 3j symbol.
!
!     M2 :IN      Parameter in 3j symbol.
!
!     M3 :IN      Parameter in 3j symbol.
!
!     L1MIN :OUT  Smallest allowable L1 in 3j symbol.
!
!     L1MAX :OUT  Largest allowable L1 in 3j symbol.
!
!     THRCOF :OUT Set of 3j coefficients generated by evaluating the
!                 3j symbol for all allowed values of L1.  THRCOF(I)
!                 will contain f(L1MIN+I-1), I=1,2,...,L1MAX+L1MIN+1.
!
!     NDIM :IN    Declared length of THRCOF in calling program.
!
!     IER :OUT    Error flag.
!                 IER=0 No errors.
!                 IER=1 Either L2 < ABS(M2) or L3 < ABS(M3).
!                 IER=2 Either L2+ABS(M2) or L3+ABS(M3) non-integer.
!                 IER=3 L1MAX-L1MIN not an integer.
!                 IER=4 L1MAX less than L1MIN.
!                 IER=5 NDIM less than L1MAX-L1MIN+1.
!
! *Description:
!
!     Although conventionally the parameters of the vector addition
!  coefficients satisfy certain restrictions, such as being integers
!  or integers plus 1/2, the restrictions imposed on input to this
!  subroutine are somewhat weaker. See, for example, Section 27.9 of
!  Abramowitz and Stegun or Appendix C of Volume II of A. Messiah.
!  The restrictions imposed by this subroutine are
!       1. L2  >=  ABS(M2) and L3  >=  ABS(M3);
!       2. L2+ABS(M2) and L3+ABS(M3) must be integers;
!       3. L1MAX-L1MIN must be a non-negative integer, where
!          L1MAX=L2+L3 and L1MIN=MAX(ABS(L2-L3),ABS(M2+M3)).
!  If the conventional restrictions are satisfied, then these
!  restrictions are met.
!
!     The user should be cautious in using input parameters that do
!  not satisfy the conventional restrictions. For example, the
!  the subroutine produces values of
!       f(L1) = ( L1  2.5  5.8)
!               (-0.31.5 -1.2)
!  for L1=3.3,4.3,...,8.3 but none of the symmetry properties of the 3j
!  symbol, set forth on page 1056 of Messiah, is satisfied.
!
!     The subroutine generates f(L1MIN), f(L1MIN+1), ..., f(L1MAX)
!  where L1MIN and L1MAX are defined above. The sequence f(L1) is
!  generated by a three-term recurrence algorithm with scaling to
!  control overflow. Both backward and forward recurrence are used to
!  maintain numerical stability. The two recurrence sequences are
!  matched at an interior point and are normalized from the unitary
!  property of 3j coefficients and Wigner's phase convention.
!
!    The algorithm is suited to applications in which large quantum
!  numbers arise, such as in molecular dynamics.
!
!***REFERENCES  1. Abramowitz, M., and Stegun, I. A., Eds., Handbook
!                  of Mathematical Functions with Formulas, Graphs
!                  and Mathematical Tables, NBS Applied Mathematics
!                  Series 55, June 1964 and subsequent printings.
!               2. Messiah, Albert., Quantum Mechanics, Volume II,
!                  North-Holland Publishing Company, 1963.
!               3. Schulten, Klaus and Gordon, Roy G., Exact recursive
!                  evaluation of 3j and 6j coefficients for quantum-
!                  mechanical coupling of angular momenta, J Math
!                  Phys, v 16, no. 10, October 1975, pp. 1961-1970.
!               4. Schulten, Klaus and Gordon, Roy G., Semiclassical
!                  approximations to 3j  and 6j coefficients for
!                  quantum-mechanical coupling of angular momenta,
!                  J Math Phys, v 16, no. 10, October 1975,
!                  pp. 1971-1988.
!               5. Schulten, Klaus and Gordon, Roy G., Recursive
!                  evaluation of 3j and 6j coefficients, Computer
!                  Phys Comm, v 11, 1976, pp. 269-278.
!***ROUTINES CALLED  D1MACH, XERMSG
!***REVISION HISTORY  (YYMMDD)
!   750101  DATE WRITTEN
!   880515  SLATEC prologue added by G. C. Nielson, NBS; parameters
!           HUGE and TINY revised to depend on D1MACH.
!   891229  Prologue description rewritten; other prologue sections
!           revised; LMATCH (location of match point for recurrences)
!           removed from argument list; argument IER changed to serve
!           only as an error flag (previously, in cases without error,
!           it returned the number of scalings); number of error codes
!           increased to provide more precise error information;
!           program comments revised; SLATEC error handler calls
!           introduced to enable printing of error messages to meet
!           SLATEC standards. These changes were done by D. W. Lozier,
!           M. A. McClain and J. M. Smith of the National Institute
!           of Standards and Technology, formerly NBS.
!   910415  Mixed type expressions eliminated; variable C1 initialized;
!           description of THRCOF expanded. These changes were done by
!           D. W. Lozier.
!***END PROLOGUE  DRC3JJ
*/

int drc3jj (double L2, double L3, double M2, double M3, /* IN, parameters */
            double *L1MIN, double *L1MAX,               /* OUT, limits of l1 */
            double * THRCOF,                            /* OUT, result */
            int NDIM,                                   /* IN, length of result */
            // int * IER,                                  /* OUT, error code, 0 ok */
            ErrorMsg errmsg)
{
  
  int I, INDEX, LSTEP, N, NFIN, NFINP1, NFINP2, NFINP3, NLIM, NSTEP2;
  double A1, A1S, A2, A2S, C1, C1OLD, C2, CNORM, D1MACH,
         DENOM, DV, EPS, HUGE_, L1, M1, NEWFAC, OLDFAC,
         ONE, RATIO, SIGN1, SIGN2, SRHUGE, SRTINY, SUM1,
         SUM2, SUMBAC, SUMFOR, SUMUNI, THREE, THRESH,
         TINY, TWO, X, X1, X2, X3, Y, Y1, Y2, Y3, ZERO;

  // *IER = 0;
  ZERO = 0.0;
  EPS = 0.01;
  ONE = 1.0;
  TWO = 2.0;
  THREE = 3.0;
  
  /* Debug - print arguments */
  // printf ("~~~ L2 = %g\n", L2);
  // printf ("~~~ L3 = %g\n", L3);
  // printf ("~~~ M2 = %g\n", M2);
  // printf ("~~~ M3 = %g\n", M3);
  
  /* HUGE is the square root of one twentieth of the largest floating point number,
  approximately. DBL_MAX is defined in float.h. */
  HUGE_ = sqrt(DBL_MAX/20.0);
  SRHUGE = sqrt(HUGE_);
  TINY = 1.0/HUGE_;
  SRTINY = 1.0/SRHUGE;

  M1 = - M2 - M3;

  /* Check error conditions 1 and 2 */
  if ( (L2-fabs(M2)+EPS < ZERO) || (L3-fabs(M3)+EPS < ZERO)) {
    // *IER=1;
    class_stop (
      errmsg,
      "L2-ABS(M2) or L3-ABS(M3) less than zero");
  }
  else if ((fmod(L2+fabs(M2)+EPS,ONE) >= EPS+EPS) || (fmod(L3+fabs(M3)+EPS,ONE) >= EPS+EPS)) {
    // *IER=2;
    class_stop (
      errmsg,
      "L2+ABS(M2) or L3+ABS(M3) not integer");
  }


  /* Limits for L1 */
  *L1MIN = MAX(fabs(L2-L3),fabs(M1));
  *L1MAX = L2 + L3;

  /* Check error condition 3 */
  if ( fmod(*L1MAX-*L1MIN+EPS,ONE) >= EPS+EPS) {
    // *IER=3;
    class_stop (
      errmsg,
      "*L1MAX-*L1MIN not integer");
  }
  if ( *L1MIN < *L1MAX-EPS)   goto _20_;
  if ( *L1MIN < *L1MAX+EPS)   goto _10_;

  /* Check error condition 4 */
  // *IER=4;
  class_stop (
    errmsg,
    "L1MIN greater than L1MAX");
  
  /* This is reached in case that L1 can take only one value i.e. L1MIN = L1MAX */
  _10_:
    THRCOF[1-1] = ALTERNATING_SIGN((int)(fabs(L2+M2-L3+M3)+EPS)) / sqrt(*L1MIN + L2 + L3 + ONE);
    return _SUCCESS_;

  /* This is reached in case that L1 takes more than one value i.e. L1MIN < L1MAX */

  _20_:
    NFIN = (int)(*L1MAX-*L1MIN+ONE+EPS);
    if ( NDIM<NFIN) goto _21_;
    else goto _23_;

  /* Check error condition 5 */
  _21_:
    // *IER=5;
    class_stop (
      errmsg,
      "Dimension of result array for 3j coefficients too small");

  /* Starting forward recursion from L1MIN taking NSTEP1 steps */

  _23_: L1 = *L1MIN;
  NEWFAC = 0.0;
  C1 = 0.0;
  THRCOF[1-1] = SRTINY;
  SUM1 = (L1+L1+ONE) * TINY;

  LSTEP = 1;
  _30_: LSTEP = LSTEP + 1;
  L1 = L1 + ONE;

  OLDFAC = NEWFAC;
  A1 = (L1+L2+L3+ONE) * (L1-L2+L3) * (L1+L2-L3) * (-L1+L2+L3+ONE);
  A2 = (L1+M1) * (L1-M1);
  NEWFAC = sqrt(A1*A2);
  if ( L1 < ONE+EPS)   goto _40_;

  DV = - L2*(L2+ONE) * M1 + L3*(L3+ONE) * M1 + L1*(L1-ONE) * (M3-M2);
  DENOM = (L1-ONE) * NEWFAC;

  if ( LSTEP<=2)  goto _32_;
  else goto _31_;

  _31_: C1OLD = fabs(C1);
  _32_: C1 = - (L1+L1-ONE) * DV / DENOM;
  goto _50_;

  /* If L1 = 1, (L1-1) has to be factored out of DV, hence */
  _40_: C1 = - (L1+L1-ONE) * L1 * (M3-M2) / NEWFAC;

  _50_: if ( LSTEP > 2)   goto _60_;

  /* If L1 = L1MIN + 1, the third term in the recursion equation vanishes, hence */
  X = SRTINY * C1;
  THRCOF[2-1] = X;
  SUM1 = SUM1 + TINY * (L1+L1+ONE) * C1*C1;
  if ( LSTEP == NFIN)   goto _220_;
  goto _30_;

  _60_: C2 = - L1 * OLDFAC / DENOM;

  /* Recursion to the next 3j coefficient X */

  X = C1 * THRCOF[LSTEP-1-1] + C2 * THRCOF[LSTEP-2-1];
  THRCOF[LSTEP-1] = X;
  SUMFOR = SUM1;
  SUM1 = SUM1 + (L1+L1+ONE) * X*X;
  if ( LSTEP == NFIN)   goto _100_;

  /* See if last unnormalized 3j coefficient exceeds SRHUGE */
  if ( fabs(X) < SRHUGE)   goto _80_;

  /* This is reached if last 3j coefficient larger than SRHUGE, so that the recursion
  series THRCOF(1), ... , THRCOF(LSTEP) has to be rescaled to prevent overflow */

  for (I=1; I <= LSTEP; ++I) {
    if ( fabs(THRCOF[I-1]) < SRTINY)
      THRCOF[I-1] = ZERO;
    THRCOF[I-1] = THRCOF[I-1] / SRHUGE;
  }

  SUM1 = SUM1 / HUGE_;
  SUMFOR = SUMFOR / HUGE_;
  X = X / SRHUGE;

  /* As long as fabs(C1) is decreasing, the recursion proceeds towards
  increasing 3j values and, hence, is numerically stable.  Once
  an increase of fabs(C1) is detected, the recursion direction is
  reversed. */

  _80_: if ( C1OLD<=fabs(C1)) goto _100_;
  else goto _30_;

  /* Keep three 3j coefficients around LMATCH for comparison with backward recursion. */
  _100_:
  X1 = X;
  X2 = THRCOF[LSTEP-1-1];
  X3 = THRCOF[LSTEP-2-1];
  NSTEP2 = NFIN - LSTEP + 3;

  /* Starting backward recursion from L1MAX taking NSTEP2 steps, so
  that forward and backward recursion overlap at three points
  L1 = LMATCH+1, LMATCH, LMATCH-1. */
  NFINP1 = NFIN + 1;
  NFINP2 = NFIN + 2;
  NFINP3 = NFIN + 3;
  L1 = *L1MAX;
  THRCOF[NFIN-1] = SRTINY;
  SUM2 = TINY * (L1+L1+ONE);

  L1 = L1 + TWO;
  LSTEP = 1;
  _110_: LSTEP = LSTEP + 1;
  L1 = L1 - ONE;

  OLDFAC = NEWFAC;
  A1S = (L1+L2+L3)*(L1-L2+L3-ONE)*(L1+L2-L3-ONE)*(-L1+L2+L3+TWO);
  A2S = (L1+M1-ONE) * (L1-M1-ONE);
  NEWFAC = sqrt(A1S*A2S);

  DV = - L2*(L2+ONE) * M1 + L3*(L3+ONE) * M1 + L1*(L1-ONE) * (M3-M2);

  DENOM = L1 * NEWFAC;
  C1 = - (L1+L1-ONE) * DV / DENOM;
  if ( LSTEP > 2)   goto _120_;

  /* If L1 = L1MAX + 1, the third term in the recursion formula vanishes */

  Y = SRTINY * C1;
  THRCOF[NFIN-1-1] = Y;
  SUMBAC = SUM2;
  SUM2 = SUM2 + TINY * (L1+L1-THREE) * C1*C1;
  goto _110_;

  _120_: C2 = - (L1 - ONE) * OLDFAC / DENOM;

  /* Recursion to the next 3j coefficient Y */
  Y = C1 * THRCOF[NFINP2-LSTEP-1] + C2 * THRCOF[NFINP3-LSTEP-1];

  if ( LSTEP == NSTEP2)   goto _200_;

  THRCOF[NFINP1-LSTEP-1] = Y;
  SUMBAC = SUM2;
  SUM2 = SUM2 + (L1+L1-THREE) * Y*Y;

  /* See if last unnormalized 3j coefficient exceeds SRHUGE */
  if ( fabs(Y) < SRHUGE)   goto _110_;

  /* This is reached if last 3j coefficient larger than SRHUGE,
  so that the recursion series THRCOF(NFIN), ... ,THRCOF(NFIN-LSTEP+1)
  has to be rescaled to prevent overflow */
  for (I=1; I <= LSTEP; ++I) {
    INDEX = NFIN - I + 1;
    if ( fabs(THRCOF[INDEX-1]) < SRTINY)
      THRCOF[INDEX-1] = ZERO;
    THRCOF[INDEX-1] = THRCOF[INDEX-1] / SRHUGE;
  }
  SUM2 = SUM2 / HUGE_;
  SUMBAC = SUMBAC / HUGE_;

  goto _110_;

  /* The forward recursion 3j coefficients X1, X2, X3 are to be matched
  with the corresponding backward recursion values Y1, Y2, Y3. */
  _200_: Y3 = Y;
  Y2 = THRCOF[NFINP2-LSTEP-1];
  Y1 = THRCOF[NFINP3-LSTEP-1];

  /* Determine now RATIO such that YI = RATIO * XI  (I=1,2,3) holds with minimal error. */
  RATIO = ( X1*Y1 + X2*Y2 + X3*Y3 ) / ( X1*X1 + X2*X2 + X3*X3 );
  NLIM = NFIN - NSTEP2 + 1;

  if ( fabs(RATIO) < ONE)   goto _211_;

  for (N=1; N <= NLIM; ++N) {
    THRCOF[N-1] = RATIO * THRCOF[N-1];
  }

  SUMUNI = RATIO * RATIO * SUMFOR + SUMBAC;
  goto _230_;

  _211_: NLIM = NLIM + 1;
  RATIO = ONE / RATIO;
  for (N=NLIM; N <= NFIN; ++N) {
    THRCOF[N-1] = RATIO * THRCOF[N-1];
  }

  SUMUNI = SUMFOR + RATIO*RATIO*SUMBAC;
  goto _230_;

  _220_: SUMUNI = SUM1;

  /* Normalize 3j coefficients */
  _230_: CNORM = ONE / sqrt(SUMUNI);

  /* Sign convention for last 3j coefficient determines overall phase */
  SIGN1 = copysign(ONE,THRCOF[NFIN-1]);
  SIGN2 = ALTERNATING_SIGN((int)(fabs(L2+M2-L3+M3)+EPS));
  if ( SIGN1*SIGN2<=0) goto _235_;
  else goto _236_;
  _235_: CNORM = - CNORM;

  _236_: if ( fabs(CNORM) < ONE)   goto _250_;

  for (N=1; N <= NFIN; ++N) {
    THRCOF[N-1] = CNORM * THRCOF[N-1];
  }

  return _SUCCESS_;

  _250_: THRESH = TINY / fabs(CNORM);
  for (N=1; N <= NFIN; ++N) {
    if ( fabs(THRCOF[N-1]) < THRESH)
      THRCOF[N-1] = ZERO;
    THRCOF[N-1] = CNORM * THRCOF[N-1];
  }

  return _SUCCESS_;

}






/*
!! DRC6J evaluates the 6j symbol h(L1) for all allowed values of L1.
!
!***PURPOSE  Evaluate the 6j symbol h(L1) = {L1 L2 L3}
!                                           {L4 L5 L6}
!            for all allowed values of L1, the other parameters
!            being held fixed.
!
!***LIBRARY   SLATEC
!***CATEGORY  C19
!***TYPE      DOUBLE PRECISION (RC6J-S, DRC6J-D)
!***KEYWORDS  6J COEFFICIENTS, 6J SYMBOLS, CLEBSCH-GORDAN COEFFICIENTS,
!             RACAH COEFFICIENTS, VECTOR ADDITION COEFFICIENTS,
!             WIGNER COEFFICIENTS
!***AUTHOR  Gordon, R. G., Harvard University
!           Schulten, K., Max Planck Institute
!***DESCRIPTION
!
! *Usage:
!
!        DOUBLE PRECISION L2, L3, L4, L5, L6, L1MIN, L1MAX, SIXCOF[NDIM-1]
!        INTEGER NDIM, IER
!
!        call DRC6J(L2, L3, L4, L5, L6, L1MIN, L1MAX, SIXCOF, NDIM, IER)
!
! *Arguments:
!
!     L2 :IN      Parameter in 6j symbol.
!
!     L3 :IN      Parameter in 6j symbol.
!
!     L4 :IN      Parameter in 6j symbol.
!
!     L5 :IN      Parameter in 6j symbol.
!
!     L6 :IN      Parameter in 6j symbol.
!
!     L1MIN :OUT  Smallest allowable L1 in 6j symbol.
!
!     L1MAX :OUT  Largest allowable L1 in 6j symbol.
!
!     SIXCOF :OUT Set of 6j coefficients generated by evaluating the
!                 6j symbol for all allowed values of L1.  SIXCOF[I-1]
!                 will contain h(L1MIN+I-1), I=1,2,...,L1MAX-L1MIN+1.
!
!     NDIM :IN    Declared length of SIXCOF in calling program.
!
!     IER :OUT    Error flag.
!                 IER=0 No errors.
!                 IER=1 L2+L3+L5+L6 or L4+L2+L6 not an integer.
!                 IER=2 L4, L2, L6 triangular condition not satisfied.
!                 IER=3 L4, L5, L3 triangular condition not satisfied.
!                 IER=4 L1MAX-L1MIN not an integer.
!                 IER=5 L1MAX less than L1MIN.
!                 IER=6 NDIM less than L1MAX-L1MIN+1.
!
! *Description:
!
!     The definition and properties of 6j symbols can be found, for
!  example, in Appendix C of Volume II of A. Messiah. Although the
!  parameters of the vector addition coefficients satisfy certain
!  conventional restrictions, the restriction that they be non-negative
!  integers or non-negative integers plus 1/2 is not imposed on input
!  to this subroutine. The restrictions imposed are
!       1. L2+L3+L5+L6 and L2+L4+L6 must be integers;
!       2. ABS(L2-L4) <= L6 <= L2+L4 must be satisfied;
!       3. ABS(L4-L5) <= L3 <= L4+L5 must be satisfied;
!       4. L1MAX-L1MIN must be a non-negative integer, where
!          L1MAX=MIN(L2+L3,L5+L6) and L1MIN=MAX(ABS(L2-L3),ABS(L5-L6)).
!  If all the conventional restrictions are satisfied, then these
!  restrictions are met. Conversely, if input to this subroutine meets
!  all of these restrictions and the conventional restriction stated
!  above, then all the conventional restrictions are satisfied.
!
!     The user should be cautious in using input parameters that do
!  not satisfy the conventional restrictions. For example, the
!  the subroutine produces values of
!       h(L1) = { L12/3  1 }
!               {2/32/32/3}
!  for L1=1/3 and 4/3 but none of the symmetry properties of the 6j
!  symbol, set forth on pages 1063 and 1064 of Messiah, is satisfied.
!
!     The subroutine generates h(L1MIN), h(L1MIN+1), ..., h(L1MAX)
!  where L1MIN and L1MAX are defined above. The sequence h(L1) is
!  generated by a three-term recurrence algorithm with scaling to
!  control overflow. Both backward and forward recurrence are used to
!  maintain numerical stability. The two recurrence sequences are
!  matched at an interior point and are normalized from the unitary
!  property of 6j coefficients and Wigner's phase convention.
!
!    The algorithm is suited to applications in which large quantum
!  numbers arise, such as in molecular dynamics.
!
!***REFERENCES  1. Messiah, Albert., Quantum Mechanics, Volume II,
!                  North-Holland Publishing Company, 1963.
!               2. Schulten, Klaus and Gordon, Roy G., Exact recursive
!                  evaluation of 3j and 6j coefficients for quantum-
!                  mechanical coupling of angular momenta, J Math
!                  Phys, v 16, no. 10, October 1975, pp. 1961-1970.
!               3. Schulten, Klaus and Gordon, Roy G., Semiclassical
!                  approximations to 3j and 6j coefficients for
!                  quantum-mechanical coupling of angular momenta,
!                  J Math Phys, v 16, no. 10, October 1975,
!                  pp. 1971-1988.
!               4. Schulten, Klaus and Gordon, Roy G., Recursive
!                  evaluation of 3j and 6j coefficients, Computer
!                  Phys Comm, v 11, 1976, pp. 269-278.
!***ROUTINES CALLED  D1MACH, XERMSG
!***REVISION HISTORY  (YYMMDD)
!   750101  DATE WRITTEN
!   880515  SLATEC prologue added by G. C. Nielson, NBS; parameters
!           HUGE and TINY revised to depend on D1MACH.
!   891229  Prologue description rewritten; other prologue sections
!           revised; LMATCH (location of match point for recurrences)
!           removed from argument list; argument IER changed to serve
!           only as an error flag (previously, in cases without error,
!           it returned the number of scalings); number of error codes
!           increased to provide more precise error information;
!           program comments revised; SLATEC error handler calls
!           introduced to enable printing of error messages to meet
!           SLATEC standards. These changes were done by D. W. Lozier,
!           M. A. McClain and J. M. Smith of the National Institute
!           of Standards and Technology, formerly NBS.
!   910415  Mixed type expressions eliminated; variable C1 initialized;
!           description of SIXCOF expanded. These changes were done by
!           D. W. Lozier.
!***END PROLOGUE  DRC6J
*/

int drc6j (double L2, double L3, double L4, double L5, double L6, /* IN, parameters */
           double *L1MIN, double *L1MAX,               /* OUT, limits of l1 */
           double * SIXCOF,                            /* OUT, result */
           int NDIM,                                   /* IN, length of result */
           // int * IER,                                  /* OUT, error code, 0 ok */
           ErrorMsg errmsg)
{

  int I, INDEX, LSTEP, N, NFIN, NFINP1, NFINP2, NFINP3, NLIM, NSTEP2;
  double A1, A1S, A2, A2S, C1, C1OLD, C2, CNORM, D1MACH,
         DENOM, DV, EPS, HUGE_, L1, NEWFAC, OLDFAC, ONE,
         RATIO, SIGN1, SIGN2, SRHUGE, SRTINY, SUM1, SUM2,
         SUMBAC, SUMFOR, SUMUNI, THREE, THRESH, TINY, TWO,
         X, X1, X2, X3, Y, Y1, Y2, Y3, ZERO;

  // *IER = 0;
  ZERO = 0.0;
  EPS = 0.01;
  ONE = 1.0;
  TWO = 2.0;
  THREE = 3.0;

  /* HUGE is the square root of one twentieth of the largest floating point number,
  approximately. DBL_MAX is defined in float.h. */
  HUGE_ = sqrt(DBL_MAX/20.0);
  SRHUGE = sqrt(HUGE_);
  TINY = 1.0/HUGE_;
  SRTINY = 1.0/SRHUGE;

  /* Check error conditions 1, 2, and 3 */
  if ( (fmod(L2+L3+L5+L6+EPS,ONE) >= EPS+EPS) || (fmod(L4+L2+L6+EPS,ONE) >= EPS+EPS)) {
    // *IER=1;
    class_stop (
      errmsg,
      "L2+L3+L5+L6 or L4+L2+L6 not integer");
  }
  else if((L4+L2-L6 < ZERO) || (L4-L2+L6 < ZERO) || (-L4+L2+L6 < ZERO)) {
    // *IER=2;
    class_stop (
      errmsg,
      "L4, L2, L6 triangular condition not satisfied");
  }
  else if ((L4-L5+L3 < ZERO) || (L4+L5-L3 < ZERO) || (-L4+L5+L3 < ZERO)) {
    // *IER=3;
    class_stop (
      errmsg,
      "L4, L5, L3 triangular condition not satisfied");
  }
 
  /* Limits for L1 */
 
  *L1MIN = MAX(fabs(L2-L3),fabs(L5-L6));
  *L1MAX = MIN(L2+L3,L5+L6);

  /* Check error condition 4 */
  if ( fmod(*L1MAX-*L1MIN+EPS,ONE) >= EPS+EPS) {
    // *IER=4;
    class_stop (
      errmsg,
      "L1MAX-L1MIN not integer");
  }
  if ( *L1MIN < *L1MAX-EPS)   goto _20_;
  if ( *L1MIN < *L1MAX+EPS)   goto _10_;

  // *IER=5;
  class_stop (
    errmsg,
    "L1MIN greater than L1MAX");

  /* This is reached in case that L1 can take only one value */
  _10_:
  SIXCOF[1-1] = ALTERNATING_SIGN((int)(L2+L3+L5+L6+EPS)) / sqrt((*L1MIN+*L1MIN+ONE)*(L4+L4+ONE));
  return _SUCCESS_;

  /* This is reached in case that L1 can take more than one value */
  _20_:
  NFIN = (int)(*L1MAX-*L1MIN+ONE+EPS);
  if ( NDIM<NFIN) goto _21_;
  else goto _23_;

  /* Check error condition 6 */
  _21_:
    // *IER=6;
    class_stop (
      errmsg,
      "Dimension of result array for 6j coefficients too small");

  /* Start of forward recursion */
  _23_:
  L1 = *L1MIN;
  NEWFAC = 0.0;
  C1 = 0.0;
  SIXCOF[1-1] = SRTINY;
  SUM1 = (L1+L1+ONE) * TINY;

  LSTEP = 1;
  _30_: LSTEP = LSTEP + 1;
  L1 = L1 + ONE;

  OLDFAC = NEWFAC;
  A1 = (L1+L2+L3+ONE) * (L1-L2+L3) * (L1+L2-L3) * (-L1+L2+L3+ONE);
  A2 = (L1+L5+L6+ONE) * (L1-L5+L6) * (L1+L5-L6) * (-L1+L5+L6+ONE);
  NEWFAC = sqrt(A1*A2);

  if ( L1 < ONE+EPS)   goto _40_;

  DV = TWO * ( L2*(L2+ONE)*L5*(L5+ONE) + L3*(L3+ONE)*L6*(L6+ONE) 
             - L1*(L1-ONE)*L4*(L4+ONE) )
                     - (L2*(L2+ONE) + L3*(L3+ONE) - L1*(L1-ONE))
                     * (L5*(L5+ONE) + L6*(L6+ONE) - L1*(L1-ONE));

  DENOM = (L1-ONE) * NEWFAC;

  if ( LSTEP<=2)  goto _32_;
  else goto _31_;

  _31_: C1OLD = fabs(C1);
  _32_: C1 = - (L1+L1-ONE) * DV / DENOM;
  goto _50_;

  /* If L1 = 1, (L1 - 1) has to be factored out of DV, hence */
  _40_: C1 = - TWO * ( L2*(L2+ONE) + L5*(L5+ONE) - L4*(L4+ONE) ) / NEWFAC;

  _50_: if ( LSTEP > 2)   goto _60_;

  /* If L1 = L1MIN + 1, the third term in recursion equation vanishes */
  X = SRTINY * C1;
  SIXCOF[2-1] = X;
  SUM1 = SUM1 + TINY * (L1+L1+ONE) * C1 * C1;

  if ( LSTEP == NFIN)   goto _220_;
  goto _30_;

  _60_: C2 = - L1 * OLDFAC / DENOM;

  /* Recursion to the next 6j coefficient X */
  X = C1 * SIXCOF[LSTEP-1-1] + C2 * SIXCOF[LSTEP-2-1];
  SIXCOF[LSTEP-1] = X;

  SUMFOR = SUM1;
  SUM1 = SUM1 + (L1+L1+ONE) * X * X;
  if ( LSTEP == NFIN)   goto _100_;

  /* See if last unnormalized 6j coefficient exceeds SRHUGE */

  if ( fabs(X) < SRHUGE)   goto _80_;

  /* This is reached if last 6j coefficient larger than SRHUGE,
  so that the recursion series SIXCOF[1-1], ... ,SIXCOF[LSTEP-1]
  has to be rescaled to prevent overflow */
  for (I=1; I <= LSTEP; ++I) {
    if ( fabs(SIXCOF[I-1]) < SRTINY)
      SIXCOF[I-1] = ZERO;
    SIXCOF[I-1] = SIXCOF[I-1] / SRHUGE;
  }

  SUM1 = SUM1 / HUGE_;
  SUMFOR = SUMFOR / HUGE_;
  X = X / SRHUGE;

  /* As long as the coefficient ABS(C1) is decreasing, the recursion
  proceeds towards increasing 6j values and, hence, is numerically
  stable.  Once an increase of ABS(C1) is detected, the recursion
  direction is reversed. */

  _80_: if ( C1OLD<=fabs(C1)) goto _100_;
  else goto _30_;

  /* Keep three 6j coefficients around LMATCH for comparison later with backward recursion */
  _100_:
  X1 = X;
  X2 = SIXCOF[LSTEP-1-1];
  X3 = SIXCOF[LSTEP-2-1];

  /* Starting backward recursion from L1MAX taking NSTEP2 steps, so
  that forward and backward recursion overlap at the three points 
  L1 = LMATCH+1, LMATCH, LMATCH-1 */
  NFINP1 = NFIN + 1;
  NFINP2 = NFIN + 2;
  NFINP3 = NFIN + 3;
  NSTEP2 = NFIN - LSTEP + 3;
  L1 = *L1MAX;

  SIXCOF[NFIN-1] = SRTINY;
  SUM2 = (L1+L1+ONE) * TINY;

  L1 = L1 + TWO;
  LSTEP = 1;
  _110_: LSTEP = LSTEP + 1;
  L1 = L1 - ONE;

  OLDFAC = NEWFAC;
  A1S = (L1+L2+L3)*(L1-L2+L3-ONE)*(L1+L2-L3-ONE)*(-L1+L2+L3+TWO);
  A2S = (L1+L5+L6)*(L1-L5+L6-ONE)*(L1+L5-L6-ONE)*(-L1+L5+L6+TWO);
  NEWFAC = sqrt(A1S*A2S);

  DV = TWO * ( L2*(L2+ONE)*L5*(L5+ONE) + L3*(L3+ONE)*L6*(L6+ONE)
             - L1*(L1-ONE)*L4*(L4+ONE) )
                     - (L2*(L2+ONE) + L3*(L3+ONE) - L1*(L1-ONE))
                     * (L5*(L5+ONE) + L6*(L6+ONE) - L1*(L1-ONE));

  DENOM = L1 * NEWFAC;
  C1 = - (L1+L1-ONE) * DV / DENOM;
  if ( LSTEP > 2)   goto _120_;

  /* If L1 = L1MAX + 1 the third term in the recursion equation vanishes */
  Y = SRTINY * C1;
  SIXCOF[NFIN-1-1] = Y;
  if ( LSTEP == NSTEP2)   goto _200_;
  SUMBAC = SUM2;
  SUM2 = SUM2 + (L1+L1-THREE) * C1 * C1 * TINY;
  goto _110_;

  _120_: C2 = - (L1-ONE) * OLDFAC / DENOM;

  /* Recursion to the next 6j coefficient Y */
  Y = C1 * SIXCOF[NFINP2-LSTEP-1] + C2 * SIXCOF[NFINP3-LSTEP-1];
  if ( LSTEP == NSTEP2)   goto _200_;
  SIXCOF[NFINP1-LSTEP-1] = Y;
  SUMBAC = SUM2;
  SUM2 = SUM2 + (L1+L1-THREE) * Y * Y;

  /* See if last unnormalized 6j coefficient exceeds SRHUGE */
  if ( fabs(Y) < SRHUGE)   goto _110_;

  /* This is reached if last 6j coefficient larger than SRHUGE,
  so that the recursion series SIXCOF[NFIN-1], ... ,SIXCOF[NFIN-LSTEP+1-1]
  has to be rescaled to prevent overflow */
  for (I=1; I <= LSTEP; ++I) {
    INDEX = NFIN-I+1;
    if ( fabs(SIXCOF[INDEX-1]) < SRTINY)
      SIXCOF[INDEX-1] = ZERO;
    SIXCOF[INDEX-1] = SIXCOF[INDEX-1] / SRHUGE;
  }

  SUMBAC = SUMBAC / HUGE_;
  SUM2 = SUM2 / HUGE_;

  goto _110_;

  /* The forward recursion 6j coefficients X1, X2, X3 are to be matched
  with the corresponding backward recursion values Y1, Y2, Y3. */
  _200_: Y3 = Y;
  Y2 = SIXCOF[NFINP2-LSTEP-1];
  Y1 = SIXCOF[NFINP3-LSTEP-1];

  /* Determine now RATIO such that YI = RATIO * XI  (I=1,2,3) holds with minimal error */
  RATIO = ( X1*Y1 + X2*Y2 + X3*Y3 ) / ( X1*X1 + X2*X2 + X3*X3 );
  NLIM = NFIN - NSTEP2 + 1;

  if ( fabs(RATIO) < ONE)   goto _211_;
  
  for (N=1; N <= NLIM; ++N) {
    SIXCOF[N-1] = RATIO * SIXCOF[N-1];
  }

  SUMUNI = RATIO * RATIO * SUMFOR + SUMBAC;
  goto _230_;

  _211_: NLIM = NLIM + 1;
  RATIO = ONE / RATIO;
  for (N=NLIM; N <= NFIN; ++N) {
    SIXCOF[N-1] = RATIO * SIXCOF[N-1];
  }  
  SUMUNI = SUMFOR + RATIO*RATIO*SUMBAC;
  goto _230_;

  _220_: SUMUNI = SUM1;

  /* Normalize 6j coefficients */
  _230_: CNORM = ONE / sqrt((L4+L4+ONE)*SUMUNI);

  /* Sign convention for last 6j coefficient determines overall phase */
  SIGN1 = copysign(ONE,SIXCOF[NFIN-1]);
  SIGN2 = ALTERNATING_SIGN((int)(L2+L3+L5+L6+EPS));
  if ( SIGN1*SIGN2<=0) goto _235_;
  else goto _236_;
  _235_: CNORM = - CNORM;

  _236_: if ( fabs(CNORM) < ONE)   goto _250_;

  for (N=1; N <= NFIN; ++N) {
    SIXCOF[N-1] = CNORM * SIXCOF[N-1];
  }

  return _SUCCESS_;

  _250_: THRESH = TINY / fabs(CNORM);
  for (N=1; N <= NFIN; ++N) {
    if ( fabs(SIXCOF[N-1]) < THRESH)
      SIXCOF[N-1] = ZERO;
    SIXCOF[N-1] = CNORM * SIXCOF[N-1];
  }

  return _SUCCESS_;

}




